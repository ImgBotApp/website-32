---
project:
  name: aura
  description: ''
  version: 0.9.0
  url: http://aurajs.com
  sha: 28ccb64
files:
  lib/ext/components.js:
    name: lib/ext/components.js
    modules: {}
    classes:
      Component: 1
    fors: {}
    namespaces: {}
  lib/ext/mediator.js:
    name: lib/ext/mediator.js
    modules: {}
    classes:
      Sandbox: 1
    fors: {}
    namespaces: {}
  lib/aura.extensions.js:
    name: lib/aura.extensions.js
    modules: {}
    classes: {}
    fors: {}
    namespaces: {}
  lib/aura.js:
    name: lib/aura.js
    modules: {}
    classes:
      Aura: 1
    fors: {}
    namespaces: {}
modules: {}
classes:
  Component:
    name: Component
    shortname: Component
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    file: lib/ext/components.js
    line: 62
    description: The base Component constructor...
    is_constructor: 1
    params:
    - name: options
      description: the options to init the component...
      type: Object
  Aura:
    name: Aura
    shortname: Aura
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    file: lib/aura.js
    line: 11
    description: |-
      Aura constructor and main entry point

      Every instance of Aura is an Aura application.
      An Aura application is in charge of loading the various
      extensions that will apply to it (defined either
      programmatically or by iway of confifuration).

      An Aura application is the glue between all the extensions
      and components inside its instance.

      Internally an Aura application wraps 4 important objects:

      - `config` is the object passed as the first param of the apps constructor
      - `core`   is a container where the extensions add new features
      - `sandbox` is an object that will be used as a prototype, to create fresh sandboxes to the components
      - `extensions` An instance of the ExtensionManager. It contains all the extensions that will be loaded in the app
          Extensions are here to provide features that will be used by the components...
          They are meant to extend the apps' core & sandbox.
          They also have access to the apps's config.

      Example of a creation of an Aura Application:

          var app = aura(config);
          app.use('ext1').use('ext2');
          app.registerComponentsSource('http://my.external/components/store', 'supercomponents');
          app.start();
    params:
    - name: config
      description: Main App config.
      type: Object
      optional: true
    itemtype: method
  Sandbox:
    name: Sandbox
    shortname: Sandbox
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    file: lib/ext/mediator.js
    line: 57
classitems:
- file: lib/ext/components.js
  line: 15
  description: Components registry
  type: '{Object}'
  class: Component
- file: lib/ext/components.js
  line: 21
  description: Components Callbacks
  class: Component
- file: lib/ext/components.js
  line: 77
  description: initialize method called on Components' initialization
  itemtype: method
  name: initialize
  params:
  - name: options
    description: options Object passed on Component initialization
    type: Object
  class: Component
- file: lib/ext/components.js
  line: 84
  description: A helper function to render markup and recursilvely start nested components
  itemtype: method
  name: html
  params:
  - name: markup
    description: the markup to render in the component's root el
    type: String
  return:
    description: the Component instance to allow methods chaining...
    type: Component
  class: Component
- file: lib/ext/components.js
  line: 123
  description: Component loader.
  params:
  - name: name
    description: The name of the Component to load
    type: String
  - name: options
    description: The options to pass to the new component instance.
    type: Object
  return:
    description: A Promise that resolves to the loaded component instance.
    type: Promise
  class: Component
- file: lib/ext/components.js
  line: 217
  description: Parses the component's options from its element's data attributes.
  params:
  - name: el
    description: the element
    type: String|DomNode
  - name: namespace
    description: current Component's detected namespace
    type: String
  - name: opts
    description: an Object containing the base Component's options to extend.
    type: String
  return:
    description: An object that contains the Component's options
    type: Object
  class: Component
- file: lib/ext/components.js
  line: 247
  description: Parses the component's options from its element's data attributes.
  params:
  - name: name
    description: the Component's name
    type: String
  - name: opts
    description: an Object containing the base Component's options to extend.
    type: Object
  return:
    description: An object that contains the component's options
    type: Object
  class: Component
- file: lib/ext/components.js
  line: 273
  description: |-
    Returns a list of component.
    If the first argument is a String, it is considered as a DomNode reference
    We then parse its content to find aura-components inside of it.
  params:
  - name: components
    description: a list of components or a reference to a root dom node
    type: Array|String
  return:
    description: a list of component with their options
    type: Array
  class: Component
- file: lib/ext/components.js
  line: 311
  description: Actual start method for a list of components.
  params:
  - name: components
    description: cf. `Component.parseList`
    type: Array|String
  return:
    description: a promise that resolves to a list of started components.
    type: Promise
  class: Component
- file: lib/ext/components.js
  line: 342
  description: |-
    Registers a function that will be executed before/after the associated
    component method.
    Once registered, every time a component method will be executed,
    the registered callbacks will execute accordingly.
    The callback functions can return a promise if required in order to
    postpone the execution of the called function up to when the callbacks
    are resolved.
    The arguments passed to the callbacks are the same than those which
    with the component will be executed. The scope of the callback is
    the component instance itself, as per the component method.
  itemtype: method
  name: registerComponentCallback
  params:
  - name: callbackName
    description: eg. 'before:initialize', 'after:remove'
    type: String
  - name: fn
    description: actual callback function to run
    type: Function
  class: Aura
- file: lib/ext/components.js
  line: 365
  description: |-
    Register a Component Type.
    Components type ca be used to encapsulate many custom
    components behaviours.
    They will be then used while declaring your components as follows:

       define({
         type: 'myComponentType',
         // component declaration...
       });
  itemtype: method
  name: registerComponentType
  params:
  - name: type
    description: a string that will identify the component type.
    type: String
  - name: def
    description: A constructor the this component type
    type: Function
  class: Aura
- file: lib/ext/components.js
  line: 392
  description: |-
    Start method.
    This method takes either an Array of Components to start or or DOM Selector to
    target the element that will be parsed to look for Components to start.
  itemtype: method
  name: start
  params:
  - name: list
    description: Array of Components to start or parent node.
    type: Array|DOM Selector
  - name: options
    description: |-
      Available options: `reset` : if true, all current children
                                           will be stopped before start.
    type: Object
  class: Sandbox
- file: lib/ext/components.js
  line: 443
  description: |-
    Stop method for a sandbox.
    If no arguments provided, the sandbox itself and all its children are stopped.
    If a DOM Selector is provided, all matching children will be stopped.
  params:
  - name: DOM
    description: Selector.
    type: Undefined|String
  class: Sandbox
- file: lib/ext/mediator.js
  line: 62
  itemtype: method
  name: 'on'
  params:
  - name: name
    description: Pattern of event to subscrbibe to.
    type: String
  class: Sandbox
- file: lib/ext/mediator.js
  line: 68
  itemtype: method
  name: once
  params:
  - name: name
    description: Pattern of event to subscrbibe to.
    type: String
  class: Sandbox
- file: lib/ext/mediator.js
  line: 74
  itemtype: method
  name: 'off'
  params:
  - name: name
    description: Pattern of event to subscrbibe to.
    type: String
  - name: listener
    description: Listener function to stop.
    type: Function
  class: Sandbox
- file: lib/ext/mediator.js
  line: 89
  itemtype: method
  name: emit
  params:
  - name: name
    description: Event name to emit
    type: String
  - name: payload
    description: Payload emitted
    type: Object
  class: Sandbox
- file: lib/ext/mediator.js
  line: 104
  itemtype: method
  name: stopListening
  class: Sandbox
- file: lib/aura.extensions.js
  line: 9
  description: |-
    Anatomy of an extension...
    TODO...
  class: Aura
- file: lib/aura.js
  line: 78
  description: |-
    Creates a brand new sandbox, using the App's sandbox object as a prototype.

    A sandbox is a way to implement the facade pattern on top of the features provided by `core`
    The `sandbox` property of an Aura application is just a blueprint (/ or factory) that will be used
    as a prototype, once the app is started, to create new instances
    of sandboxed environments for the components.
  itemtype: method
  name: createSandbox
  params:
  - name: ref
    description: the Sandbox unique ref.
    type: String
    optional: true
  - name: options
    description: an object to that directly extends the Sandbox
    type: Object
    optional: true
  return:
    description: a shiny new Sandbox instance.
    type: Sandbox
  class: Aura
- file: lib/aura.js
  line: 108
  description: Get a sandbox by its reference
  itemtype: method
  name: getSandbox
  params:
  - name: ref
    description: the Sandbox ref to retreive.
    type: String
  class: Aura
- file: lib/aura.js
  line: 118
  description: |-
    Tells the app to load the given extension.

     aura extensions are loaded in the app during init.
     they are responsible for :

     - resolving & loading external dependencies via requirejs
     - they have a direct access to the app's internals
     - they are here to add new features to the app... that are made available through the sandboxes to the components.



     Extensions can have multiple forms :

    * *Module name*

    ````
    aura().use('my/ext')
    ````

    * *Function*

    ````
    var ext = function(app) {
     app.core.hello = function() {  alert("Hello World") };
    }
    aura().use(ext);
    ````
    * *Object litteral*

    ````
    var ext = {
     require: {},
     initialize: function(app) {
       app.core.hello = function() {  alert("Hello World") };
     }
    }
    aura().use(ext);
    ````

     The Object litteral form allows :

     - to add dependencies
     - to add lifecycle callbacks (ex. `afterAppStart`)

     here is an example of a very simple backbone extension:

    ````
    define(function() {
     var historyStarted = false;
     var ext = {
       require: {
         paths: {
           backbone:     'components/backbone/backbone'
           underscore:   'components/underscore/underscore'
         },
         shim: {
           backbone: { exports: 'Backbone', deps: ['underscore'] }
         }
       },
       initialize: function(app) {
         app.core.mvc = require('backbone');
         app.sandbox.View = function(view) { return app.core.mvc.View.extend(view); }
       },
       afterAppStart: function(app) {
         if (historyStarted) return;
         Backbone.history.start();
         historyStarted = true;
       }
     }
     return ext;
    });
    ````

     The extension provides the path mapping of its dependencies (backbone).
     When the extension is used in an app, the ExtManager configures
     requirejs with the right paths and requires all of them.

     Actually what it will do corresponds to (pseudo-code):

         function requireExtension(ext) {
           require.config({ paths: { ... }, shim: { ... } })
           require(['backbone', 'underscore'], function(Backbone, _) {
             $.when(ext.initialize(app)).then( ... load next extension ... );
           })
         }


     When all the extension's dependencies are required, the `init` method is called.
     `ext.init` may return a promise, ExtManager wait for `ext.init` resolution to load the next extension.

     When all the app's extensions are finally loaded, the extensions `ext.afterAppStart` methods are then called.

     ... then the app is considered ready !

     After `app.start` has been called, it is not possible to register new extensions.

     *Example of an extension with an initialize method that returns a promise*

     Let's wrap FB sdk as an aura extension :

         var facebookExtension = {

           require: {
             paths: {
               facebook: 'http://connect.facebook.net/en_US/all.js'
             }
           },

           initialize: function(app) {
             var status = app.core.data.deferred();
             app.sandbox.auth = {
               login: FB.login,
               logout: FB.logout
             };

             FB.init({ appId: 'xxx' });

             FB.getLoginStatus(function(res) {
               app.sandbox.auth.loginStatus = res;
               status.resolve(res);
             }, true);

             return status;
           },

           afterAppStart: function(app) {
             console.warn("The app is started and I am : ", app.sandbox.auth.loginStatus);
           }

         }

         aura().use(facebookExtension).start().then(function() {
           console.warn("My app is now started... and I am sure that getLoginStatus has been called and has returned somthing...");
         });
    This method can only be called before the app is actually started.
    Note that the app is started when its `start` method is called.
  itemtype: method
  name: use
  params:
  - name: ref
    description: the reference of the extension
    type: String | Object | Function
  return:
    description: the Aura app object
    type: Aura
  chainable: 1
  class: Aura
- file: lib/aura.js
  line: 266
  description: |-
    Adds a new source for components.
    A Component source is an endpoint (basically a URL)
    that is the root of a component repository.
  itemtype: method
  name: registerComponentsSource
  params:
  - name: name
    description: the name of the source.
    type: String
  - name: baseUrl
    description: the base url for those components.
    type: String
  class: Aura
- file: lib/aura.js
  line: 283
  description: |-
    Application start.

    Bootstraps the extensions loading process.
    All the extensions are resolved and loaded when `start` id called.
    Start returns a promis e that shall fail if any of the
    extensions fails to load.

    The app's responsibility is to load its extensions,
    make sure they are properly loaded when the app starts
    and eventually make sure they are properly cleaned up when the app stops
  itemtype: method
  name: start
  params:
  - name: options
    description: start options.
    type: Object | String | Array
  return:
    description: a promise that resolves when the app is started.
    type: Promise
  class: Aura
- file: lib/aura.js
  line: 347
  description: Stops the application and unregister its loaded dependencies.
  todo:
  - ': We need to do a little more cleanup here...'
  itemtype: method
  name: stop
  return:
    description: ''
    type: Void
  class: Aura
warnings:
- message: |-
    Missing item type
    Components registry
  line: ' lib/ext/components.js:15'
- message: |-
    Missing item type
    Components Callbacks
  line: ' lib/ext/components.js:21'
- message: |-
    Missing item type
    Component loader.
  line: ' lib/ext/components.js:123'
- message: |-
    Missing item type
    Parses the component's options from its element's data attributes.
  line: ' lib/ext/components.js:217'
- message: |-
    Missing item type
    Parses the component's options from its element's data attributes.
  line: ' lib/ext/components.js:247'
- message: |-
    Missing item type
    Returns a list of component.
    If the first argument is a String, it is considered as a DomNode reference
    We then parse its content to find aura-components inside of it.
  line: ' lib/ext/components.js:273'
- message: |-
    Missing item type
    Actual start method for a list of components.
  line: ' lib/ext/components.js:311'
- message: |-
    Missing item type
    Stop method for a sandbox.
    If no arguments provided, the sandbox itself and all its children are stopped.
    If a DOM Selector is provided, all matching children will be stopped.
  line: ' lib/ext/components.js:443'
- message: |-
    Missing item type
    Anatomy of an extension...
    TODO...
  line: ' lib/aura.extensions.js:9'
